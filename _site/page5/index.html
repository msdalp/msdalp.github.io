<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      msdalp &middot; java, android, etc.
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-89611351-1', 'auto');
  ga('send', 'pageview');

</script>
  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="msdalp" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
      <h3 class="masthead-title">
<a href="/" title="Home">msdalp</a>
<small>java, android, etc.</small>

  &nbsp;&nbsp;&nbsp;
  <small><a href="/about">About</a></small>

  &nbsp;&nbsp;&nbsp;
  <small><a href="/archive">Archive</a></small>

  &nbsp;&nbsp;&nbsp;
  <small><a href="/atom.xml">Feed</a></small>


</h3>

      </header>

      <main>
        <div class="posts">
  
  <article class="post">
    <h1 class="post-title">
      <a href="/2014/03/09/Udp-on-Android/">
        Android Udp Client Example
      </a>
    </h1>

    <time datetime="2014-03-09T20:46:32+01:00" class="post-date">09 Mar 2014</time>

    UDP (User Datagram Protocol) is anther commonly used protocol on the Internet. However, UDP is never used to send important data such as webpages,
database information, etc; UDP is commonly used for streaming audio and video. Streaming media such as Windows Media audio files (.WMA) , Real Player (.RM),
and others use UDP because it offers speed! The reason UDP is faster than TCP is because there is no form of flow control or error correction. 
The data sent over the Internet is affected by collisions, and errors will be present. Remember that UDP is only concerned with speed.
This is the main reason why streaming media is not high quality.<br>
Besides UDP a is connectionless protocol. Communication is datagram oriented. The integrity is guaranteed only on the single datagram.
Datagrams reach destination and can arrive out of order or don't arrive at all. Is more efficient than TCP because it uses non ack.
It's generally used for real time communication, where a little percentage of packet loss rate is preferable to the overhead of a TCP connection.

These are the general details of the UDP you can find anywhere.I assume you decided that it's better to use UDP on you Android application here some ways to implement 
client for UDP.A client can send data to server, can listen for coming data from a port or send a data to server and wait for answer.<br>

First we start with sending data to server.You need datagramsocket and datagrampacket to send data to server.DatagramSocket is the port we will send and DatagramPacket is the data
we will send represented as bytes.It may throw SocketException when you try to create a new DatagramSocket object or IOException when you try to send data.

{% highlight java %}
public class ClientSend implements Runnable {
        @Override
        public void run() {
            try {
                DatagramSocket udpSocket = new DatagramSocket(port);
                InetAddress serverAddr = InetAddress.getByName(ip);
                byte[] buf = ("The String to Send").getBytes();
                DatagramPacket packet = new DatagramPacket(buf, buf.length,serverAddr, port);
                udpSocket.send(packet);
            } catch (SocketException e) {
                Log.e("Udp:", "Socket Error:", e);
            } catch (IOException e) {
                Log.e("Udp Send:", "IO Error:", e);
            }
        }
}
{% endhighlight %}
Just sending data may not be enough.You can listen a port as well.Listening a port is done by infinite loops since you don't know when to stop listening.
We should prefer run flags for this than can close the loop when the job is done.If you just use while(true) you can see on your logcat it is still listening even the application
is not open on the main screen.The data size will be defined first as byte here so use a reasonable number.If you choose a small number it will give unexpected errors.

{% highlight java %}
public class ClientListen implements Runnable {
  @Override
  public void run() {
  boolean run = true;
	while (run) {
	  try {
	    DatagramSocket udpSocket = new DatagramSocket(port);
	    byte[] message = new byte[8000];
	    DatagramPacket packet = new DatagramPacket(message,message.length);
	    Log.i("UDP client: ", "about to wait to receive");
	    udpSocket.receive(packet);
	    String text = new String(message, 0, packet.getLength());
	    Log.d("Received data", text);
	  }catch (IOException e) {
	    Log.e("UDP client has IOException", "error: ", e);
	    run = false;
	  }
	}
  }
}	
{% endhighlight %}
There is also another way to write listener by giving it listening time.How can we use such an implementmation?
It may work first you send a data to server like "FILES" asking for files on the server.And set the listening time with setSoTimeout() method and start listening.
You should catch the exception which is SocketTimeoutException if there is no answer.
{% highlight java %}
public class ClientSendAndListen implements Runnable {
        @Override
        public void run() {
            boolean run = true;
            try {
                DatagramSocket udpSocket = new DatagramSocket(portVal);
		InetAddress serverAddr = InetAddress.getByName(ipVal);
                byte[] buf = ("FILES").getBytes();
                DatagramPacket packet = new DatagramPacket(buf, buf.length,serverAddr, port);
                udpSocket.send(packet);
                while (run) {
                    try {
                        byte[] message = new byte[8000];
                        DatagramPacket packet = new DatagramPacket(message,message.length);
                        Log.i("UDP client: ", "about to wait to receive");
                        udpSocket.setSoTimeout(10000);
                        udpSocket.receive(packet);
                        String text = new String(message, 0, p.getLength());
                        Log.d("Received text", text);                        
                    } catch (IOException e) {
                        Log.e(" UDP client has IOException", "error: ", e);
                        run = false;
                        udpSocket.close();
                    } catch (SocketTimeoutException e) {
                        Log.e("Timeout Exception","UDP Connection:",e);
                        run = false;
                        udpSocket.close();
                    }
                }
            } catch (SocketException e) {
                Log.e("Socket Open:", "Error:", e);
            }
        }
}
{% endhighlight %}
The last thing is how to call these Clients from you main activity.Remember these were Runnable so you should start these with Thread.
{% highlight java %}
package msd.udp.test;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.EditText;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.SocketTimeoutException;
public class MainActivity extends Activity {
    private String ip;
    private int port;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        udpConnect = new Thread(new ClientSendAndListen()).start();
    }
}
{% endhighlight %}

  </article>
  
  <article class="post">
    <h1 class="post-title">
      <a href="/2014/03/04/jetty-embedded/">
        Jetty Embedded Server With Post, Get, and Gson
      </a>
    </h1>

    <time datetime="2014-03-04T17:40:24+01:00" class="post-date">04 Mar 2014</time>

    Jetty is used in a wide variety of projects and products, both in development and production. Jetty can be easily embedded in devices, tools, frameworks, application servers, and clusters. See the <a href="http://www.eclipse.org/jetty/powered">Jetty Powered page</a> for more uses of Jetty.Here we want to use it as an embedded web server that runs with our application.
You should first download the required jetty jar files and import them. Basically you can just down <a href="http://repo1.maven.org/maven2/org/eclipse/jetty/aggregate/jetty-all/9.1.0.v20131115/jetty-all-9.1.0.v20131115.jar">jetty all</a> and use it there will no problem. For now the latest version is the 9.1 and it is the one we will use.Also Gson will be used and you should download it from <a href="https://code.google.com/p/google-gson/downloads/detail?name=google-gson-2.2.4-release.zip&can=2&q=">this</a> link.
First create a class that extends Server and by giving port to its constructor we will be able to start it easily.
{% highlight java %}
package com.msd.jetty;
 
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.servlet.ServletContextHandler;
import org.eclipse.jetty.servlet.ServletHolder;
 
public class Jetty extends Server {
 
    private static final Gson gson = new GsonBuilder().
    setDateFormat("yyyy-MM-dd HH:mm:ss").create();
 
    public Jetty(int port) {
        super(port);
 
        ServletContextHandler context = new ServletContextHandler(ServletContextHandler
        .NO_SESSIONS);
        context.setContextPath("/test");
        context.addServlet(new ServletHolder(new GetName(gson)), "/GetName/*");
        context.addServlet(new ServletHolder(new SaveName()), "/SaveName/*");
        this.setHandler(context);
        this.setStopAtShutdown(true);
    }
 
}
{% endhighlight %}
By using context.addServlet() method you can add servlets easily.addServlet() takes two parameters and the first one is the class name that will be called when this servlet called and the second one is the name how you will call it.
{% highlight java %}
context.addServlet(new ServletHolder(new SaveName()), "/SaveName/*");
{% endhighlight %}
  will be called as localhost:portNumber/test/SaveName 
GET methods are defined using doGet and POST methods are defined with doPost.SaveName and GetName classes are

{% highlight java %}
package com.msd.jetty;
 
 
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
 
@SuppressWarnings("serial")
public class SaveName extends HttpServlet {
 
    public SaveName() {
    }
 
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
                                             throws ServletException, IOException {
        try {
            final long timeStamp = System.currentTimeMillis();
            final String name = request.getParameter("name");
            final String surName = request.getParameter("surName");
            System.out.println("name:"+name+" surname:"+surName);
            response.setStatus(HttpServletResponse.SC_OK);
 
        } catch (Exception ex) {
            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
 
        } finally {
            response.setContentType("text/html;charset=UTF-8");
            response.getWriter().println("");
            response.getWriter().close();
        }
    }
 
}
{% endhighlight %}
And the get method we will use:
{% highlight java %}
package com.msd.jetty;
 
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
 
@SuppressWarnings("serial")
public class GetName extends HttpServlet {
 
    private final Gson gson;
 
    public GetTeamDictionary(Gson gson) {
        this.gson = gson;
    }
 
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) 
                                            throws ServletException, IOException {
        String output = "";
        try {
            final JsonObject retVal = new JsonObject();
            
            retVal.add("name", "jetty");
            retVal.add("surname", "is awasome");
            output = retVal.toString();
            response.setStatus(HttpServletResponse.SC_OK);
 
        } catch (Exception ex) {
            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
 
        } finally {
            response.setContentType("text/html;charset=UTF-8");
            response.getWriter().println(output);
            response.getWriter().close();
        }
    }
 
}
{% endhighlight %}


It's all that simple and now you only need to start to jetty server from your main class.
{% highlight java %}

package com.msd.jetty;
 
public class App {
 
    public static void main(String[] args) {
            final Jetty jetty = new Jetty(8080);
            jetty.start();
            Thread.sleep(500);
            if (false == jetty.isStarted()) {
                throw new Exception("Cannot start jetty server");
            }
    }
}
{% endhighlight %}
When your application is running you can call localhost:8080/test/GetName and it will return to you a json object like this
{% highlight json %}
{
  "name": "jetty",
  "surname": "is awesome"
}
{% endhighlight %}
You can use HTTP:POST to send data to server by using localhost:8080/test/SaveName and your post parameters should be named as "name" and "surName".It is the simplest thing you can do with jetty embedded server.I use it to get data from database using parameters and posting data into database and it's really fast and lightweight which makes it really feasible.



  </article>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page6">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page4">Newer</a>
    
  
</div>


      </main>
      <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    // Required: on line below, replace text in quotes with your forum shortname
    var disqus_shortname = 'msdalp';
    // var disqus_developer = 1;

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

      <footer class="footer">
        <small>
          &copy; <time datetime="2018-04-16T19:53:39+02:00">2018</time>. All rights reserved.
        </small>
      </footer>
    </div>

  </body>
</html>
